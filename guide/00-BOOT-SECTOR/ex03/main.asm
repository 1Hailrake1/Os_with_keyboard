; ------------------------------------------------------------------------------
; Guide:	00-BOOT-SECTOR
; File:		ex03 / main.asm
; Title:	Простая программа загрузочного сектора (boot sector), которая 
;			демонстрирует работу стека
; ------------------------------------------------------------------------------
; Description:
;	Цель: разобраться как работать со стеком на языке Ассемблер.
;	Теория:
;	1. Стек - структура данных, которая действует по принциу LIFO (last in first
;	out). Со стеком можно провести две операции: добавить в стек элемент
;	(добавлять можно только в конец) и взять элемент из стека (взять можно 
;	только последний элемент). О стеке удобно думать как о стопке блинов.
;	2. Регистры для работы со стеком: bp и sp. bp содержит адрес начала стека,
;	а sp - адрес конца стека (т.е. начала стопки блинов и ее макушка соответсв.)
;	3. Стек, с которым мы будем работать, "растет" вниз, то есть мы добавляем 
;	значения в стек по адресу меньше конца стека. Допустим, если адрес конца 
;	стека находится в регистре sp и равен 0x8000, то добавляя что-нибудь в стек, 
;	значение регистра sp станет 0x8000 - 0x2 (если размер этого "чего-нибудь"
;	равен 2 байтам).
;	4. Операции со стеком: "push <значение>" чтобы добавить какое-либо значение 
;	в конец стека, "pop <регистр>" чтобы удалить последнее значение из стека и 
;	добавить его в указанный регистр.
; ------------------------------------------------------------------------------


mov ah, 0x0e			; Перемещаем число 0x0e в регистр ah, указывая BIOS'у
						; что нам нужна рутина tele-type, то есть режим вывода 
						; информации на экран

mov bp, 0x8000			; bp - регистр адреса начала стека, а sp - конца стека
mov sp, bp				; мы размещаем стек чуть выше адреса, из которого БИОС
						; загружает наш загрузочный сектор (в адресе 0x8000),
						; чтобы случайно не задеть загрузочный сектор.
						; Переносим адрес bp в sp, т.к. изначально стек пустой,
						; и поэтому адрес конца стека равен адресу начала

push 'A'				; Добавляем в стек символы
push 'B'
push 'C'


pop bx					; Переносим последнее значение из стека в регистр bx
						; (помним, что значение sp увеличится, а не уменьшится, 
						; т.к. стек "растет" вниз)
mov al, bl				; в bl находится значение*, взятое из стека с помощью 
						; команды pop. Перемещаем его в регистр al
int 0x10				; Выводим 'C'


pop bx					; Переносим в регистр bx следующее значение из стека
mov al, bl 
int 0x10				; Выводим 'B'


mov al, [0x8000 - 0x2]	; Переносим в регистр al значение по адресу 0x7ffe
						; (0x8000 - 0x2), т.е. адрес начала стека минус 2 байта,
						; для того чтобы подтвердить, что стек "растет" вниз
int 0x10				; Выводим 'A'

						; ------------------------------------------------------

jmp $					; бесконечный цикл

the_secret:				; Объявляем метку the_secret,
	db 'X'				; объявляем байт, и инициализируем его с числом,
						; соответствующим символу 'X' в таблице ASCII


times 510-($-$$) db 0	; Заполняем ненужные байты нулями

dw 0xaa55				; Вставляем в конец "магическое число"

; ------------------------------------------------------------------------------
; * почему bl, а не bx? Регистр bx устроен так, что состоит из двух других
;	регистров: bh и bl (оба размером 8 байт, а размер bx соответственно 16 байт)
;	Подобным образом же устроен и регистр ax, т.е. ah и al. Т.к. мы используем
;	регистр al, равный 8 байтам, чтобы выводить символы на экран, то нам нужно 
;	перемещать в этот регистр значение из регистра такого же размера. Поэтому
;	мы перемещаем туда значение из bl. (гугли: регистры в ассемблере)