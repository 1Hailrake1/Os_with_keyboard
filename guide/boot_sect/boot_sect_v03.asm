; =========================== BOOT SECTOR GUIDE V01 ============================
; Простая программа загрузочного сектора (boot sector), которая демонстрирует
; работу стека
; ------------------------------------------------------------------------------
; Цель: разобраться как работать со стеком на языке Ассемблер.
; Теория:
; 1. Стек - структура данных, которая действует по принциу LIFO (last in first
; out). Со стеком можно провести две операции: добавить в стек элемент
; (добавлять можно только в конец) и взять элемент из стека (взять можно только
; последний элемент). О стеке удобно думать как о стопке блинов.
; 2. Стек "растет" вниз, то есть мы добавляем значения в стек по адресу меньше
; конца стека. Допустим, если адрес конца стека находится в регистре sp и равен
; 0x8000, то добавляя что-нибудь в стек, значение регистра sp станет
; 0x8000 - 0x2 (т.к. размер значения в стеке = 2 байта).
; 3. Операции со стеком: "push <значение>" чтобы добавить какое-либо значение в
; конец стека, "pop <регистр>" чтобы удалить последнее значение из стека и 
; добавить его в указанный регистр.
; ------------------------------------------------------------------------------
; Чтобы перевести наш файл boot_sect.asm в машинный код, нужно написать:
; nasm boot_sect.asm -f bin -o boot_sect.bin
; ------------------------------------------------------------------------------
; Справочник по синтаксису ассемблера NASM можно найти тут: 
; https://www.opennet.ru/docs/RUS/nasm/nasm_ru3.html


mov ah, 0x0e			; Перемещаем число 0x0e в регистр ah, указывая BIOS'у
						; что нам нужна рутина tele-type, то есть режим вывода 
						; информации на экран

mov bp, 0x8000			; bp - регистр адреса начала стека, а sp - конца стека
mov sp, bp				; мы размещаем стек чуть выше адреса, из которого БИОС
						; загружает наш загрузочный сектор (в адресе 0x8000),
						; чтобы случайно не задеть загрузочный сектор.
						; Переносим адрес bp в sp, т.к. изначально стек пустой,
						; и поэтому адрес конца стека равен адресу начала

push 'A'				; Добавляем в стек символы
push 'B'
push 'C'


pop bx					; Переносим последнее значение из стека в регистр bx
						; (помним, что значение sp увеличится, а не уменьшится, 
						; т.к. стек "растет" вниз)
mov al, bl				; в bl находится значение, удаленное с помощью команды
						; pop из стека. Перемещаем его в регистр al
int 0x10				; Выводим 'C'


pop bx					; Переносим в регистр bx следующее значение из стека
mov al, bl 
int 0x10				; Выводим 'B'


mov al, [0x8000 - 0x2]	; Переносим в регистр al значение по адресу 0x7ffe
						; (0x8000 - 0x2), т.е. адрес начала стека минус 2 байта,
						; для того чтобы подтвердить, что стек "растет" вниз
int 0x10				; Выводим 'A'

						; ------------------------------------------------------

jmp $					; бесконечный цикл

the_secret:				; Объявляем метку the_secret,
	db 'X'				; объявляем байт, и инициализируем его с ASCII кодом,
						; соответствующим символу 'X'


times 510-($-$$) db 0	; Заполняем ненужные байты нулями

dw 0xaa55				; Вставляем в конец "магическое число"